---
title: 2.Java运行时数据区

comments: true    

tags: 
    - 深入了解java虚拟机
    - java

categories: 
    - java虚拟机

description:

date: 2017-02-05 #文章生成時間
   
---

## *概述* : 
#### Java将new的对象的管理权交由Java虚拟机,so对于Java程序员,不需要写配套的delete/free代码,不容易出现内存溢出或泄露,但是一旦出现了,就需要了解虚拟机如何使用内存来排除bug
----------
#### Java虚拟机在执行程序时会把管理的内存划分为多个不同的数据区域,
{% asset_img 20161215182730152.png 图片标题 %}

----------

### **1.程序计数器**--->*线程私有的区域*
#### 占用内存较小,作用是**作为当前线程执行的字节码的行号指示器**。
#### 在概念模型里,字节码解释器工作时通过改变程序计数器的值来选取下一条需要执行的字节码指令。分支，循环，跳转，异常处理，线程恢复等基础功能都需要此计数器完成。
#### Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，so每次处理器只执行一个线程。 so **每个线程都拥有一个独立的程序计数器**，各线程计数器互不影响，独立储存。
#### 若执行的是Native方法，则程序计数器值为空（Undefined） <------唯一


<!--more-->

----------

### **2.Java虚拟机栈**--->*线程私有的区域*
#### 描述了Java方法执行的内存模式，每个方法在执行同时会创建一个栈帧，用来存储

 1. **局部变量表** （编译时即确定内存大小，方法执行时不会改变其大小）
 1.1. 存放编译期各种可知的基本数据类型  (64位长度的long，double占两个局部变量空间，其他占一个)
 1.2. 对象引用  (指向对象其实地址的指针或是指向代表对象的句柄或其他与此对象相关的位置)
 1.3. returnAddress类型  (指向一个字节码指令的地址)
 2. **操作数栈**
 3. **动态链接**
 4. **方法出口**

#### **方法的执行就是栈帧在虚拟机栈中的入栈到出栈的过程**。
#### 人们常说的Java内存分配的堆内存(Heap)，栈内存(Stack) 中 后者就是这里的虚拟机栈。
#### 当线程请求的栈深度大于虚拟机所允许的深度 --------- *StackOverflowError*（当然，目前虚拟机栈都是可以动态扩展的）
#### 当无法申请到足够的内存 --------------------*OutOfMemoryError*
----------

### **3.本地方法栈**（Native Method Stack）
#### 功能与虚拟机栈相似

 - 虚拟机栈：为虚拟机执行Java方法（字节码）服务
 - 本地方法栈：为虚拟机使用的Native方法服务 
 - ----------

### **4.Java堆**--->*所有线程共享*
#### 内存最大，虚拟机启动时创建， Java垃圾收集器主要管理区域（也叫**GC堆**）
#### 作用：**存放对象实例（和数组）** 即为对象实例分配内存
#### 可以进行进一步划分多个线程私有的分配缓冲区
#### 可以处于物理不连续的内存空间，但逻辑连续；可以实现成扩展，也可以固定（可通过-Xmx -Xms控制）
 - ----------
### **5.方法区**--->*所有线程共享*
#### 用于**存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等**
#### 别名 Non-Heap 
#### 可以物理内存不连续， 可以固定或可扩展， 可选择不实现垃圾收集（需要对常量池回收和对类型进行卸载，否则 易出现内存泄漏）
 - ----------

### **6.运行时常量池（Runtime Constant Pool）**
#### 方法区的一部分，用于**存储编译期生成的各种字面符号引用(一般也存储翻译出来的直接引用)**
#### Java对Class文件每部分（类版本，字段，方法，接口，常量池等）格式有严格规定，符合规定才能被虚拟机认可，装载，执行。but对运行时常量池，无规定。
#### 具有**动态性**（Class文件常量池无动态性） 
 - ----------

### **7.直接内存（堆外内存）**
#### 不是虚拟机运行时数据区的一部分，不归虚拟机管理
#### 减少了垃圾回收的工作（垃圾回收会暂停其他的工作）
#### 加快了复制的速度。因为堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。 
#### 堆外内存难以控制，如果内存泄漏，那么很难排查 
#### 堆外内存相对来说，不适合存储很复杂的对象。一般简单的对象或者扁平化的比较适合。
此处来源：http://blog.csdn.net/qq_17612199/article/details/52316719