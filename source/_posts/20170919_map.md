---
title: 网状关系: 图

comments: true    

tags: 
    - C语言

categories: 
    - 数据结构和算法

description: 

---

> 图: 


<!--more-->

```aidl
        #include <stdio.h>
        #include <stdlib.h>
        
        #define VERTEX_MAX 26
        #define MAXVALUE 32767
        
        typedef struct
        {
            char Vertex[VERTEX_MAX];            //保存顶点信息（序号或字母）
            int Edges[VERTEX_MAX][VERTEX_MAX];  //保存边的权
            int isTrav[VERTEX_MAX];             //遍历标志
            int VertexNum;                      //顶点数量
            int EdgeNum;                        //边数量
            int GraphType;                      //图的类型(0无向图 1有向图)
        } MatrixGraph;                          //定义邻接矩阵图结构
        
        void CreateMatrixGraph(MatrixGraph *G); //创建邻接矩阵图
        void OutMatrix(MatrixGraph *G);         //输出邻接矩阵
        
        void CreateMatrixGraph(MatrixGraph *G)
        {
            int i, j, k, weight;
            char start, end;                    //边的起始顶点
        
            printf("输入各顶点的信息：\n");       //输入顶点
            for(i=0; i<G->VertexNum; i++)
            {
                fflush(stdin);
                printf("第%d个顶点信息：", i+1);
                scanf("%c", &(G->Vertex[i]));
            }
        
            printf("输入构成各边的两个顶点以及权值：\n");
        
            for(k=0; k<G->EdgeNum; k++)
            {
                printf("第%d条边：", k+1);
                fflush(stdin);
                scanf("%c %c %d", &start, &end, &weight);
                for(i=0; start!=G->Vertex[i]; i++);     //查找已有的顶点中是否包含当前的"起始顶点"
                for(j=0; end!=G->Vertex[j]; j++);       //同上
        
                // printf("%d %d", i, j);
                G->Edges[i][j] = weight;               //对应位置保存权值，表示有一条边
                if(G->GraphType == 0)                   //判断是不是无向图
                {
                    G->Edges[j][i] = weight;            //在对角位置保存权值
                }
            }
        }
        
        void OutMatrix(MatrixGraph *G)
        {
            int i, j;
        
            printf(" ");
            for(j=0; j<G->VertexNum; j++)
                printf("\t%c", G->Vertex[j]);           //输出顶点信息
            printf("\n");
        
            for(i=0; i<G->VertexNum; i++)
            {
                printf("%c", G->Vertex[i]);
                for(j=0; j<G->VertexNum; j++)
                {
                    if(G->Edges[i][j] >= MAXVALUE) //如果权值为最大值
                        printf("\t #");                 //输出无穷大符号
                    else
                        printf("\t%d", G->Edges[i][j]); //输出边的权值
                }
        
                printf("\n");
            }
        }
        
        int main()
        {
            MatrixGraph G;
            int i, j;
            printf("输入生成图的类型 （0无向图 1有向图）");
            scanf("%d", &G.GraphType);
            printf("输入图的顶点数量和边数量");
            scanf("%d %d", &G.VertexNum, &G.EdgeNum);       //输入图顶点数和边数
            for(i=0; i<G.VertexNum; i++)
            {
                for(j=0; j<G.VertexNum; j++)
                {
                    G.Edges[i][j] = MAXVALUE;               //初始化元素值为最大值
                }
            }
            CreateMatrixGraph(&G);
        
            OutMatrix(&G);
        
            return 0;
        }
        
```

---
---

```aidl
           #include <stdio.h>
           #include <stdlib.h>
           
           #define VERTEX_MAX 26
           
           typedef struct edgeNode
           {
               int Vertex;             //顶点信息
               int weight;             //权值
               struct edgeNode *next;  //下一个顶点地址指针
           }EdgeNode;                  //顶点的结构
           
           typedef struct
           {
               EdgeNode* AdjList[VERTEX_MAX];  //顶点指针
               int VextexNum, EdgeNum;         //顶点数量,边数量
               int GraphType;                  //图的类型(0无向图 1有向图)
           }ListGraph;                         //图的结构
           
           void CreateGraph(ListGraph *G);
           void OutList(ListGraph *G);
           
           void CreateGraph(ListGraph *G)
           {
               int i, weight;
               int start, end;
               EdgeNode *s;
               for(i=0; i<=G->VextexNum; i++)      //初始化
                   G->AdjList[i] = NULL;
           
               printf("输入构成各边的两个顶点以及权值：\n");
           
               for(i=0; i<G->EdgeNum; i++)
               {
                   printf("第%d条边", i+1);
                   fflush(stdin);
                   scanf("%d %d %d", &start, &end, &weight);
                   s = (EdgeNode *)malloc(sizeof(EdgeNode));
                   s->next = G->AdjList[start];
                   s->Vertex = end;
                   s->weight = weight;
                   G->AdjList[start] = s;
                   if(G->GraphType == 0)
                   {
                       s = (EdgeNode *)malloc(sizeof(EdgeNode));
                       s->next = G->AdjList[end];
                       s->Vertex = start;
                       s->weight = weight;
                       G->AdjList[end] = s;
                   }
               }
           }
           
           void OutList(ListGraph *G)
           {
               int i;
               EdgeNode *s;
               for(i=0; i<=G->VextexNum; i++)
               {
                   printf("顶点%d", i);
                   s = G->AdjList[i];
                   while(s)
                   {
                       printf("->%d(%d)", s->Vertex, s->weight);
                       s = s->next;
                   }
                   printf("\n");
               }
           }
           
           int main()
           {
               ListGraph G;
               printf("输入生成图的类型 （0无向图 1有向图）");
               scanf("%d", &G.GraphType);
               printf("输入图的顶点数量和边数量");
               scanf("%d %d", &G.VextexNum, &G.EdgeNum);
           
               CreateGraph(&G);
               OutList(&G);
           
               return 0;
           }

        
```


> 个人博客 欢迎来访： http://ay2626.me