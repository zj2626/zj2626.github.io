---
title: 数据结构随笔

comments: true    

tags: 

categories: 
    - 数据结构和算法

description: 

---

# *线性表*

|         | 顺序存储           | 链式存储  |
| ------------- |:-------------:| -----:|
| 分配方式    | 连续的存储单元 依次存储 | 链式存储结构 |
| 查找时间复杂度 |   O(1)   |  O(n)  |
| 更新时间复杂度 |   O(n)   |  O(1)  |
| 空间 |   固定   |  可扩展  |

1.  ##顺序存储

        封装顺序存储结构 三个条件
            1.起始位置
            2.最大容量
            3.当前长度
            
        优点: 1.无需为表中逻辑关系增加额外的存储空间(空间是紧挨着的) 2.读取元素速度快
        缺点: 1.插入,删除操作复杂速度慢  2.易造成空间碎片化 
            
        EG: ***********************************
            #define MAXSIZE 20
            typedef int ElemType;
            typedef struct
            {
                ElemType data[MAXSIZE];//内存中的存储位置页数连续的 下标从0开始
                int length; //当前长度
            } SqList;
            
            ***********************************
            

<!--more-->

> 顺序存储元素操作

    
            // 1. 获取list中的某个元素
            
            #define OK 1
            #define ERROR 0
            #define TRUE 1
            #define FALSE 0
            
            typedef int Status; //返回值类型 状态码
            
            // i是取第几个位置的值 则其位置下标为 i-1; *e即为获取的元素
            Status GetElem(SqList L, int i, ElemType *e)
            {
                if(L.length==0 || i>L.length)
                {
                    return ERROR;
                }
            
                *e = L.data[i-1];
            
                return OK;
            }
            
            测试结果: http://okow3aoov.bkt.clouddn.com/c_1.png
            
            __________________________________________________________
            __________________________________________________________
            
            
            // 2. 插入元素到list的指定的位置
            
            Status ListInsert(SqList *L, int i, ElemType e) //i插入的位置 e插入的数据
            {
                int k;
            
                if(L -> length == MAXSIZE)//判断List顺序表的实际长度是否已经达到最大长度,即是否已经满了 ( -> 用来取子数据)
                {
                    return ERROR;
                }
            
                if(i<1 || i>L->length+1) //判断i在不在已有数据组成的表范围之内
                {
                    return ERROR;
                }
            
                if(i<=L->length) //在合理的范围内
                {
                    for(k=L->length-1; k>= i-1; k--)//从后往前一个一个向后移动一位 (eg: a[1]是第二个元素)
                    {
                        L->data[k+1] = L->data[k];
                    }
                }
            
                L->data[i-1] = e; //把数据插入到该位置
                L->length++;    //表长度增加
            
                return OK;
            }
            
            测试结果: http://okow3aoov.bkt.clouddn.com/c_b.png

            __________________________________________________________
            __________________________________________________________
            
            

            // 3. 删除元素从list的指定的位置
            
            Status ListDelete(SqList *L, int i, ElemType *e)// i是删除的位置 *e是删除的元素
            {
                int k;
            
                if(L->length == 0)
                {
                    return ERROR;
                }
            
                if(i<1 || i > L->length)
                {
                    return ERROR;
                }
            
                *e = L->data[i-1]; //被删除的元素
            
                if(i >= 1) //在合理的范围内
                {
                    for(k=i; k<= L->length-1; k++)//从前往后一个一个向前移动一位 (eg: a[1]是第二个元素)
                    {
                        L->data[k-1] = L->data[k];
                    }
                }
            
                L->length--;    //表长度减少
            
                return OK;
            }
            
            测试结果: http://okow3aoov.bkt.clouddn.com/c_c.png


---

    
2.  ##链式存储


        特色: 用一组任意的存储单元存储线性表的数据元素, 每个地址叫结点, 需要存储元素(数据域)和其后继元素的地址(指针域, 内部数据叫指针或链)
        
        *只有一个指针域 --> 单链表
        
        *头指针 -- > 指向头结点的指针(永不为空,即使链表为空); 
        *头结点 --> 第一个结点 (不存储数据,数据域可以存放链表长度) ; 
        *最后一个结点指向空(NULL); 
        *空链表 -- > 有头结点和头指针, 没有其他结点, 直接指向NULL
        
        
        EG: ***********************************
                    typedef struct Node
                    {
                        ElemType data;      //数据域
                        struct Node* next;  //指针域
                    } Node;
                    
                    typedef struct Node* LinkList;  //取Node*的别名为LinkList
                    
                    //LinkList p;   p->data  p->next
            ***********************************


> 链式存储元素操作

           
           // 1. 获取list中的某个元素
            
            Status GetElemL(LinkList L, int i, ElemType *e)
            {
                int j;
                LinkList p; //p即为一个指针 指向链表
                
                p = L->next;//使p指向当前链表的第一个结点
                j = 1;
                
                while( p && j < i)//判断p不为空 且没到要查询的结点 查到或者到头了就退出循环
                {
                    p = p->next;
                    ++j;
                }
                
                if(!p || j > i) //没找到   
                {
                    return ERROR;
                }
                
                *e = p->data;
                
                return OK;
            }
            
            测试结果: http://okow3aoov.bkt.clouddn.com/blog_c13.png

            __________________________________________________________
            __________________________________________________________
            
            // 2. 插入元素到list的指定的位置
            
            Status ListInsertL(LinkList L, int i, ElemType e) //i插入的位置 e插入的数据
            {
                int j;
                LinkList p, s;
            
                p = L;
                j = 1;
            
                while(p && j<i)//循环遍历链表 使p指向一个一个结点直到最后(p结点为null)或者到达要插入的地方
                {
                    p = p->next;
                    j++;
                }
            
                if(!p || j>i) // 判断要插入的位置存在
                {
                    return ERROR;
                }
            
                s = (LinkList)malloc(sizeof(Node)); //生成新的结点 结点大小=sizeof(Node) 然后强转
                s->data = e;    //设置结点数据域
            
                s->next = p->next; //把插入结点的上一个结点的指针赋给要插入的结点的指针域
                p->next = s;        //把插入结点的上一个结点的指针指向插入的结点
            
                return OK;
            }
            
            测试结果: http://okow3aoov.bkt.clouddn.com/blog_c14.png
            
            __________________________________________________________
            __________________________________________________________
            
            // 3. 删除元素从list的指定的位置
            
            Status ListRemove(LinkList L, int i, ElemType *e)// i是删除的位置 *e是删除的元素
            {
                int j;
                LinkList p, q;
            
                p = L;    //先指向头结点, 要删除的结点从头结点指向的结点开始算起;即到最后要删除结点是p->next
                j = 1;
            
                while(p->next && j<i)//循环遍历链表 使p指向一个一个结点直到最后(p结点指针指向null)或者到达要插入的地方
                {
                    p = p->next;
                    j++;
                }
            
                if(!(p->next) || j>i) // 判断要删除的结点存在
                {
                    return ERROR;
                }
            
                q = p->next;    //q结点是要删除的结点
                p->next = q->next; //q结点指针域可能指向null(q是最后一个结点时候)
            
                free(q); //释放空间
            
                return OK;
            }
            
            测试结果: http://okow3aoov.bkt.clouddn.com/blog_c15.png
            


> 链式存储整表创建(建立单链表) (顺序存储 == 数组)

#### 头插法

            // 1. 头插法建立单链表: 
            //      把新加入的结点插入到链表头部, 把头结点指向新插入的结点(会使插入的结点顺序与原先设定的顺序颠倒)
            
            void CreateListHead(LinkList *L, int n)
            {
                LinkList p;
                int i;
            
//                srand(time(0));  //初始化随机数
            
                //这里L是指针 *L表示链表头结点
                *L = (LinkList)malloc(sizeof(Node)); //初始化一个链表的头结点(可以放在函数外面)
                (*L)->next = NULL;  //设置头结点默认指向null
            
                for(i=0; i<n; i++)
                {
                    p = (LinkList)malloc(sizeof(Node)); //新建结点
                    p->data = rand() % 100 + 1; //随机数赋值到每个结点的数据域
                    p->next = (*L)->next;       //把原来的头结点指针指向的地址赋值给新建的结点(因为要插入到头部)
                    (*L)->next = p;             //更新头结点指针域
                }
            }
            
            测试结果: http://okow3aoov.bkt.clouddn.com/bolg_c10.png



#### 尾插法

  
            // 1. 尾插法建立单链表: 
            
            void CreateListTail(LinkList *L, int n)
            {
                LinkList p, r;
                int i;
            
//                srand(time(0));
            
                *L = (LinkList)malloc(sizeof(Node)); //初始化一个链表的头结点
                r = *L; //使r指向生成的链表(当前只有头结点 所以r指向头结点)   /*定义一个临时指针变量指向表头*/
            
                for(i=0; i<n; i++)
                {
                    p = (Node *)malloc(sizeof(Node)); //新建结点
                    p->data = rand() % 100 + 1; //随机数赋值到每个结点的数据域
                    r->next = p;   //使r的指针域指向新的结点
                    r = p;          //把新结点赋给r r指向链表的最后一个结点
                }
                r->next = NULL; //当全部插入的之后 要把最后一个节点的指针域指向NULL
            }
            
            
            测试结果: http://okow3aoov.bkt.clouddn.com/blog_c12.png



> 链式存储整表删除


            Status ClearList(LinkList L)
            {
                LinkList p, q;
                    
                p = L->next;
                
                while(p)
                {
                    q = p->next;
                    free(p);   //p指向每次都释放的地址
                    p = q;
                }
                
                L->next = NULL;
                
                return OK;
            }

    
3.  ##静态链表: 用数组实现链表

#### 定义
  
    #define MAXSIZE 1000
    typedef struct
    {
        ElemType data;  //数据
        int cur;        //游标(Cursor)
    } Component, StaticLinkList[MAXSIZE];
    


#### 初始化

  
        Status InitList(StaticLinkList space)
        {
            int i;
            for(i=0; i < MAXSIZE-1; i++)
            {
                space[i].cur = i + 1;   
            }
            
            space[MAXSIZE-1].cur = 0;
            
            return OK;
        }
