---
title: 回溯算法 (实例)

comments: true    

tags: 
    - C语言

categories: 
    - 数据结构和算法

description: 

---


## 使用回溯算法解决N皇后问题

> 回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。用回溯算法解决问题的一般步骤为：

1. 定义一个解空间，它包含问题的解。
2. 利用适于搜索的方法组织解空间。
3. 利用深度优先法搜索解空间。
4. 利用限界函数避免移动到不可能产生解的子空间。

> 问题的解空间通常是在搜索问题的解的过程中动态产生的，这是回溯算法的一个重要特性

> 要求：N皇后问题：在n*n格的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋的规矩，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n后问题等价于在n*n格的棋盘上方置n个皇后，任何2个皇后不放在同一行或同一列或同一斜线上。我们需要求的是可放置的总数

> 例子：如下图
        

{% qnimg 2014217145358979.png title:回溯法 alt:图片说明 'class:class_name class_name2' extend:?imageView2/2/w/600 %}


<!--more-->
        
        
      #include <stdio.h>
      #include <math.h>
      #include<stdlib.h>
      // n表示在 n*n 的坐标中进行操作
      // 数组x[k]中 下表k表示横轴 x[k]得值表示纵轴
      static int n, x[1000];
      static long sum;
      
      //尝试 判断是否可以 如果不可以则回退到t+1层，再尝试其他的组合
      int Place(int k)
      {
          int j;
          for( j = 1;j < k; j++)//循环遍历已经确定位置的坐标(j表示行号) 与当前要选择的坐标进行对比
              if((abs(k - j) == abs(x[j] - x[k])) || (x[j] == x[k]))
                  //三个条件 1.任意两个不能在同一个斜边上 2.不能在同一行 3.不能在同一列(即j==k)
                  return 0;
           return 1;
        }
      
      void Backtrak(int k) //初始1
      {
         if(k > n)
              sum++;//如果超过最后一行就算成功一个
         else{
              int i;
              for( i=1; i <= n; i++){ // 循环一行的每个每一个空位,从1到n
                  x[k] = i; // 表示第k行第i列
                  if(Place(k)) // 判断
                      Backtrak(k+1); // 操作完成 进行下一行
              }
         }
      }
      
      int main()
      {
          int nn;
          printf("请输入2的整数次幂的数: ");
          while(scanf("%d",&nn)!=EOF){
              n=nn;
              sum=0;
      
              int i;
              for(i=0;i<=n;i++)
                  x[i]=0;
      
              Backtrak(1);
              printf("%l\n",sum);
          }
      }
  
