<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="欢迎来到晋的博客,本博客用来收录平时学习笔记,欢迎访问"><title>哈夫曼(霍夫曼)树以及哈夫曼编码 | ZJ_BLOG</title><link rel="stylesheet" type="text/css" href="/zj2626.github.io/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/zj2626.github.io/favicon.ico"><link rel="apple-touch-icon" href="/zj2626.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/zj2626.github.io/apple-touch-icon.png"><script type="text/javascript" src="/zj2626.github.io/js/instantclick.min.js"></script><script>InstantClick.init();
InstantClick.on('change', function (isInitialLoad) {
         if (isInitialLoad === false) {
         if (typeof MathJax !== 'undefined') // support MathJax
         MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
         if (typeof prettyPrint !== 'undefined') // support google code prettify
         prettyPrint();
         if (typeof _hmt !== 'undefined')  // support 百度统计
         _hmt.push(['_trackPageview', location.pathname + location.search]);
         if (typeof ga !== 'undefined')  // support google analytics
         ga('send', 'pageview', location.pathname + location.search);
         }
 });
</script><link rel="alternate" type="application/atom+xml" href="/zj2626.github.io/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">哈夫曼(霍夫曼)树以及哈夫曼编码</h1><a id="logo" href="/zj2626.github.io/.">ZJ_BLOG</a><p class="description">Silence的博客</p></div><div id="nav-menu"><a class="current" href="/zj2626.github.io/."><i class="fa fa-home"> 首页</i></a><a href="/zj2626.github.io/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">哈夫曼(霍夫曼)树以及哈夫曼编码</h1><div class="post-meta">Mar 11, 2021<span> | </span><span class="category"><a href="/zj2626.github.io/categories/数据结构和算法/">数据结构和算法</a></span></div><div class="post-content"><blockquote>
<p>哈夫曼树：又称最优二叉树，是一种带权路径长度最短的二叉树；<br>哈夫曼编码：哈夫曼树的一个应用，如JPEG中就应用；</p>
</blockquote>
<pre><code>所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度
（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。
树的带权路径长度记为WPL = (W1*L1+W2*L2+W3*L3+...+Wn*Ln)，
N个权值Wi(i=1,2,...n)构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li(i=1,2,...n)。
可以证明哈夫曼树的WPL是最小的。

一般权值用来表示频率大小，频率越大则权值越高
</code></pre><a id="more"></a>        
<blockquote>
<p>参考博客1： <a href="http://www.cnblogs.com/junyuhuang/p/4127095.html" target="_blank" rel="noopener">http://www.cnblogs.com/junyuhuang/p/4127095.html</a></p>
</blockquote>
<blockquote>
<p>参考博客2： <a href="http://www.cnblogs.com/Jezze/archive/2011/12/23/2299884.html" target="_blank" rel="noopener">http://www.cnblogs.com/Jezze/archive/2011/12/23/2299884.html</a></p>
</blockquote>
<blockquote>
<p>####哈弗曼编码原理(转载)</p>
</blockquote>
<pre><code>    　　哈夫曼编码使用一种特别的方法为信号源中的每个符号设定二进制码。出现频率更大的符号将获得更短的比特，出现频率更小的符号将被分配更长的比特，以此来提高数据压缩率，提高传输效率。具体编码步骤主要为，

    　　1、统计：

    　　在开始编码时，通常都需要对信号源，也就是本文的一段文字，进行处理，计算出每个符号出现的频率，得到信号源的基本情况。接下来就是对统计信息进行处理了

    　　

    　　2、构造优先对列：

    　　把得到的符号添加到优先队列中，此优先队列的进出逻辑是频率低的先出，因此在设计优先队列时需要如此设计，如果不熟悉优先队列，请阅读相关书籍，在此不做过多概述。得到包含所有字符的优先队列后，就是处理优先队列中的数据了。


    　　3、构造哈夫曼树：

    　　哈夫曼树是带权值得二叉树，我们使用的哈夫曼树的权值自然就是符号的频率了，我们构建哈夫曼树是自底向上的，先构建叶子节点，然后逐步向上，最终完成整颗树。先把队列中的一个符号出列，也就是最小频率的符号，，然后再出列一个符号。这两个符号将作为哈夫曼树的节点，而且这两个节点将作为新节点，也就是它们父节点，的左右孩子节点。新节点的频率，即权值，为孩子节点的和。把这个新节点添加到队列中(队列会重新根据权值排序)。重复上面的步骤，两个符号出列，构造新的父节点，入列……直到队列最后只剩下一个节点，这个节点也就是哈夫曼树的根节点了。

    　　

    　　4、为哈弗曼树编码：

    　　哈夫曼树的来自信号源的符号都是叶子节点，需要知道下。树的根节点分配比特0，左子树分配0，右字数分配1。然后就可以得到符号的码值了。
</code></pre><blockquote>
<p>####哈夫曼编码步骤 </p>
</blockquote>
<p>1.首先构建一个元素为哈夫曼树结点的数组用于存储哈夫曼树（线性）；</p>
<pre><code>哈夫曼树数据结构包括元素数据、权值、父结点位置（数组下标）、两个子结点位置

typedef struct
{
    int weight;
    int parent;
    int lchild;
    int rchild;
    int value;
} HNodeType
</code></pre><p>2.初始化数组，设置树元素的默认属性；然后输入要编码的数据及其权值，存储到数组前几位，这几个即为哈夫曼树的叶子结点；</p>
<pre><code>哈夫曼树中有效的数据仅仅是叶子结点，
而非叶子结点是为了构建哈夫曼树而加入的
</code></pre><p>3.开始构建哈夫曼树：找出整个数组中有数据且权值最低的两个作为新构造的二叉树的左右子树，新二叉树的根结点的权值为其左右子树的根结点的权值之和；<br>    然后把新构建的根结点存放到数中空位置，然后继续从整个数组中寻找。。。直到有效元素全部读取。</p>
<p>4.编码,树的根节点分配比特0，左子树分配0，右字数分配1;</p>
<p>5.解码,思路就是 把要解码的字符串像学中学方程一样代入到哈夫曼树中，按照左子树分配0，右字数分配1的原则，一个一个遍历出来</p>
<hr>
<hr>
<pre><code>示例(转载)：

　　假如我有A,B,C,D,E五个字符，出现的频率（即权值）分别为5,4,3,2,1,
那么我们第一步先取两个最小权值作为左右子树构造一个新树，即取1，2构成新树，其结点为1+2=3，如图：
</code></pre><p>　　<img src="/zj2626.github.io/2021/03/11/20170908_hfms/201112231832078695.png" title="哈夫曼树"></p>
<pre><code>　  虚线为新生成的结点，第二步再把新生成的权值为3的结点放到剩下的集合中，所以集合变成{5,4,3,3}，再根据第二步，取最小的两个权值构成新树，如图：
</code></pre><p>　　<img src="/zj2626.github.io/2021/03/11/20170908_hfms/201112231832087092.png" title="哈夫曼树"></p>
<pre><code>再依次建立哈夫曼树，如下图：
</code></pre><p>　　<img src="/zj2626.github.io/2021/03/11/20170908_hfms/201112231832084301.jpg" title="哈夫曼树"></p>
<pre><code>其中各个权值替换对应的字符即为下图：
</code></pre><p>　　<img src="/zj2626.github.io/2021/03/11/20170908_hfms/201112231832086286.jpg" title="哈夫曼树"></p>
<pre><code>如下图也可以加深大家的理解：
</code></pre><p>　　<img src="/zj2626.github.io/2021/03/11/20170908_hfms/272122409653995.gif" title="哈夫曼树"></p>
<hr>
<hr>
<blockquote>
<p>代码实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Name:   哈夫曼编码源代码。</span></span><br><span class="line"><span class="comment"> * Date:   2011.04.16</span></span><br><span class="line"><span class="comment"> * Author: Jeffrey Hill+Jezze(解码部分)</span></span><br><span class="line"><span class="comment"> * 在 Win-TC 下测试通过</span></span><br><span class="line"><span class="comment"> * 实现过程：着先通过 HuffmanTree() 函数构造哈夫曼树，然后在主函数 main()中</span></span><br><span class="line"><span class="comment"> *           自底向上开始(也就是从数组序号为零的结点开始)向上层层判断，若在</span></span><br><span class="line"><span class="comment"> *           父结点左侧，则置码为 0,若在右侧,则置码为 1。最后输出生成的编码。</span></span><br><span class="line"><span class="comment"> *------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结点个数 = 叶子结点个数 * 2 - 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBIT      100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVALUE  10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEAF     30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNODE    MAXLEAF*2 -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">bit</span>[MAXBIT];    <span class="comment">//结点的编码</span></span><br><span class="line">    <span class="keyword">int</span> start;          <span class="comment">//结点编码的起始位，有效位置，如当start=2， 则该结点的编码从bit[2]开始</span></span><br><span class="line">&#125; HCodeType;        <span class="comment">/* 编码结构体 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">    <span class="keyword">int</span> lchild;</span><br><span class="line">    <span class="keyword">int</span> rchild;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; HNodeType;        <span class="comment">/* 结点结构体 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造一颗哈夫曼树 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanTree</span><span class="params">(HNodeType HuffNode[MAXNODE],  <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*  i、j： 循环变量，</span></span><br><span class="line"><span class="comment">        m1、m2：构造哈夫曼树不同过程中两个最小权值结点的权值，</span></span><br><span class="line"><span class="comment">        x1、x2：构造哈夫曼树不同过程中两个最小权值结点在数组中的序号。*/</span></span><br><span class="line">    <span class="keyword">int</span> i, j, m1, m2, x1, x2;</span><br><span class="line">    <span class="comment">/* 初始化存放哈夫曼树数组 HuffNode[] 中的结点 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        HuffNode[i].weight = <span class="number">0</span>;<span class="comment">//权值</span></span><br><span class="line">        HuffNode[i].parent = <span class="number">-1</span>;<span class="comment">//父结点位置初始化为-1，表示没有父结点，到时候要通过该属性进行判断，排除掉已加入到树的元素</span></span><br><span class="line">        HuffNode[i].lchild = <span class="number">-1</span>;<span class="comment">//初始化左子树根节点位置</span></span><br><span class="line">        HuffNode[i].rchild = <span class="number">-1</span>;<span class="comment">//初始化右子树根节点位置</span></span><br><span class="line">        HuffNode[i].value = i;  <span class="comment">//实际值，可根据情况替换为字母</span></span><br><span class="line">    &#125; <span class="comment">/* end for */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用户输入 n 个叶子结点的权值 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第 %d 个元素的权值: \n"</span>, i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;HuffNode[i].weight);</span><br><span class="line">    &#125; <span class="comment">/* end for */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 循环构造 Huffman 树 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)      <span class="comment">// 循环叶子结点的个数，一次循环要形成一个“新”的二叉树</span></span><br><span class="line">    &#123;</span><br><span class="line">        m1 = m2 = MAXVALUE;         <span class="comment">//m1、m2中存放两个无父结点且结点权值最小的两个结点</span></span><br><span class="line">        x1 = x2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找出所有结点中权值最小、无父结点的两个结点，并合并之为一颗二叉树</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n + i; j++)  <span class="comment">//循环数组中元素个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要找到当前数组中所有的元素中最小的两位，处理之后又把结果存到数组中所以要(n+i)</span></span><br><span class="line">            <span class="keyword">if</span>(HuffNode[j].weight &lt; m1 &amp;&amp; HuffNode[j].parent == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当前的权值更小，把当前元素赋值给m1，把原来m1的赋值给m2</span></span><br><span class="line">                m2 = m1;</span><br><span class="line">                x2 = x1;</span><br><span class="line">                m1 = HuffNode[j].weight;</span><br><span class="line">                x1 = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(HuffNode[j].weight &lt; m2 &amp;&amp; HuffNode[j].parent == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当前的权值大于m1但是小于m2，把其赋值给m2</span></span><br><span class="line">                m2 = HuffNode[j].weight;</span><br><span class="line">                x2 = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">/* end for */</span></span><br><span class="line">        <span class="comment">/* 最终，m1每次存放最小权值，m2存放次小的 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置 找到的两个子结点 x1、x2 的父结点信息 */</span></span><br><span class="line">        <span class="comment">/* 父结点存放到数组的下标为(n + i)的位置 */</span></span><br><span class="line">        HuffNode[x1].parent  = n + i;</span><br><span class="line">        HuffNode[x2].parent  = n + i;</span><br><span class="line">        <span class="comment">/* 设置 父结点的属性 */</span></span><br><span class="line">        HuffNode[n + i].weight = HuffNode[x1].weight + HuffNode[x2].weight;</span><br><span class="line">        HuffNode[n + i].lchild = x1;</span><br><span class="line">        HuffNode[n + i].rchild = x2;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第 %d 次循环的两个结果的权值为: %d, %d\n"</span>, i + <span class="number">1</span>, HuffNode[x1].weight, HuffNode[x2].weight); <span class="comment">/* 用于测试 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125; <span class="comment">/* end for */</span></span><br><span class="line">    <span class="comment">/*  for(i=0;i&lt;n+2;i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            printf(" Parents:%d,lchild:%d,rchild:%d,value:%d,weight:%d\n",HuffNode[i].parent,HuffNode[i].lchild,HuffNode[i].rchild,HuffNode[i].value,HuffNode[i].weight);</span></span><br><span class="line"><span class="comment">        &#125;*/</span><span class="comment">//测试</span></span><br><span class="line">&#125; <span class="comment">/* end HuffmanTree */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decodeing</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[], HNodeType Buf[], <span class="keyword">int</span> Num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//tmp：循环中临时存放哈夫曼树数组的元素下标，从大到小</span></span><br><span class="line">    <span class="keyword">int</span> i, tmp = <span class="number">0</span>, code[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span> * Num - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *nump;</span><br><span class="line">    <span class="keyword">char</span> num[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">string</span>[i] == <span class="string">'0'</span>)</span><br><span class="line">            num[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    nump = &amp;num[<span class="number">0</span>];<span class="comment">//nump指向要解码的字符数组的第一个元素的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" 解码结果为： "</span>);</span><br><span class="line">    <span class="keyword">while</span>(nump &lt; (&amp;num[len]))<span class="comment">//循环遍历要解码的字符数组（即输入的解码前字符串），直到最后一个数组元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp = m - <span class="number">1</span>;<span class="comment">//每次循环设置初始元素下标，设置为 哈夫曼树数组 的最后一个有效数据元素的下标（树的根节点）</span></span><br><span class="line">        <span class="keyword">while</span>((Buf[tmp].lchild != <span class="number">-1</span>) &amp;&amp; (Buf[tmp].rchild != <span class="number">-1</span>))<span class="comment">//循环判断该元素有没有子结点，直到没有子结点，则说明遍历到叶子结点，则说明找到一个解码的结果</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*nump == <span class="number">0</span>)  <span class="comment">//判断要解码的字符数组的当前元素是否为0 0表示左结点 1表示有结点</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp = Buf[tmp].lchild ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp = Buf[tmp].rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            nump++;                     <span class="comment">//数组元素是字符，每个元素只占一个字节，所以++也就是地址加一，指向数组下一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, nump, &amp;num[<span class="built_in">strlen</span>(<span class="built_in">string</span>)], Buf[tmp].value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    HNodeType HuffNode[MAXNODE];            <span class="comment">/* 定义一个结点结构体数组 */</span></span><br><span class="line">    HCodeType HuffCode[MAXLEAF],  cd;       <span class="comment">/* 定义一个编码结构体数组， 同时定义一个临时变量来存放求解编码时的信息(即cd.bit存放当前结点的编码的倒序，cd.start存放结点编码开始位置) */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        i、j： 循环变量，</span></span><br><span class="line"><span class="comment">        c 循环体中当前的结点在数组中的下标</span></span><br><span class="line"><span class="comment">        p 当前结点的父结点在数组中的下标</span></span><br><span class="line"><span class="comment">        n 有效数据的个数（叶子结点的个数）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i, j, c, p, n;</span><br><span class="line">    <span class="keyword">char</span> pp[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input n:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    HuffmanTree(HuffNode, n);<span class="comment">//生成哈夫曼树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*对哈夫曼树进行编码*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//循环所有的有效数据，一个一个进行编码 (0 ~ n-1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cd.start = n - <span class="number">1</span>;       <span class="comment">//</span></span><br><span class="line">        c = i;                  <span class="comment">//c 当前结点在数组中的下标 整体上来说可以表示循环在“树”中走过的结点下标</span></span><br><span class="line">        p = HuffNode[c].parent; <span class="comment">//p 当前结点的父结点在数组中的下标</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span>)    <span class="comment">/* 判断父结点存在 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(HuffNode[p].lchild == c) <span class="comment">//判断当前结点是不是父结点的左子树根节点 如果是的话就 赋值0</span></span><br><span class="line">                cd.<span class="built_in">bit</span>[cd.start] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>                        <span class="comment">//如果不是的话就 赋值1 &gt;&gt;&gt;&gt; 因为“左子树分配0，右字数分配1”</span></span><br><span class="line">                cd.<span class="built_in">bit</span>[cd.start] = <span class="number">1</span>;</span><br><span class="line">            cd.start--;        <span class="comment">/* 求编码的低一位 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 设置下一循环条件 */</span></span><br><span class="line">            c = p;                  <span class="comment">//设置c为父结点的下标 准备进行下次while循环，则那时候的“当前的结点”就会变成现在结点的父结点</span></span><br><span class="line">            p = HuffNode[c].parent; <span class="comment">//同理</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">/* end while */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 保存 求出的每个叶结点的哈夫曼编码和编码的起始位 */</span></span><br><span class="line">        <span class="keyword">for</span>(j = cd.start + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            HuffCode[i].<span class="built_in">bit</span>[j] = cd.<span class="built_in">bit</span>[j];</span><br><span class="line">        &#125;</span><br><span class="line">        HuffCode[i].start = cd.start + <span class="number">1</span>;   <span class="comment">//编码的起始位</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">/* end for */</span></span><br><span class="line">    <span class="comment">/*对哈夫曼树进行编码结束*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印已保存好的所有存在编码的哈夫曼编码 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第%d位置的树结点的编码为：: "</span>, i);</span><br><span class="line">        <span class="keyword">for</span>(j = HuffCode[i].start; j &lt; n; j++)<span class="comment">//从有效位置开始输出该结点的编码</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, HuffCode[i].<span class="built_in">bit</span>[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 结点的属性bit数组中有效的编码开始位置为:bit[%d]\n"</span>, HuffCode[i].start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打印结束 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Decoding?Please Enter code:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;pp);</span><br><span class="line">    decodeing(pp, HuffNode, n);</span><br><span class="line">    getch();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>个人博客 欢迎来访： <a href="http://zj2626.github.io">http://zj2626.github.io</a></p>
</blockquote>
</div><script type="text/javascript" src="/zj2626.github.io/js/share.js?v=0.0.1" async></script><a class="article-share-link" data-url="http://zj2626.github.io/2021/03/11/20170908_hfms/" data-id="ckpdsvlzn00265wut32ekeiln" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACHElEQVR42u3aQY7DIAwF0N7/0p3tSKMk3zYdqfBYRW1CeFlY2Pj1isf7dvy+5+r++zn//v76xMDAwPhaRr7E+1f27ql+jstPg4GBcQDjKoL1pk54OfL+KQwMDIz762rgzoMsBgYGxtqAmySf+aYQAwMDY5LE5svqBdzJnBgYGHsz8qr7/19/5HwDAwPjqxjv4kiCb36oUC3kXb4FAwNja0Ye4Cak6mFndT0YGBhnMpIgmB8S5BvN6jwPFTgMDIyNGMnU+bKqmWa1nPewHgwMjE0Z8xR00iqRBNzoXwwMjE0ZeWDNQ2ovAe4df2JgYJzDyENtwpu3aJRTWQwMjK0Z1eaG8rFiaxPZO/7EwMDYlTEJuHnwzTd8vTCNgYGxN2O+gaumu6swDycbGBgYGzGS5ebF/VWpabnYh4GBcTCjdwyQJ67JR4mSWwwMjAMYycPVVoxqMa4a7pvfAAMD4wsZvYerKe7kYxW2iRgYGFszeo1c1TGZrbd5xcDA2ImRBLs8FOYpaM6LjlExMDAOYPRaKFZV6avNFhgYGGcyqgF31bFBb5v40HKBgYGxEeNdHHnOOE9Z880lBgbG3oxJsSwJr/PSf576YmBg7M2ohsveIvJ0tBmyMTAwDmDkSeYnmjOW5eIYGBgYg96GKqncEIaBgYFRvJ68q7d5xcDAOIGxti1s0mZRLd5hYGCcwMhTx3KrVjGtnW9YMTAwtmP8AK66YL7/ReEMAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/zj2626.github.io/tags/C语言/">C语言</a></div><div class="post-nav"><a class="pre" href="/zj2626.github.io/2021/03/11/20170911_list_clone/">待完成</a><a class="next" href="/zj2626.github.io/2021/03/11/20170906_xsecs/">线索二叉树</a></div><div id="container"></div><link rel="stylesheet" href="/zj2626.github.io/css/default.css?v=0.0.1"><script src="/zj2626.github.io/js/gitment.browser.js?v=0.0.1"></script><script>var gitment = new Gitment({
  owner: 'zj2626',
  repo: 'zj2626.github.io',
  oauth: {
    client_id: '22769c7edffa5f05d10d',
    client_secret: '7bac8fc03397cb64c178fbdfe3a01d2abb459704',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/BUG解决/">BUG解决</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/DOM操作/">DOM操作</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/DOM操作/XML/">XML</a><span class="category-list-count">6</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/JDBC/">JDBC</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/java虚拟机/">java虚拟机</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/java语言基础/">java语言基础</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/python/">python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/多线程/">多线程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/数据库/">数据库</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/数据库连接池/">数据库连接池</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/数据结构和算法/">数据结构和算法</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/机器学习/">机器学习</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/框架相关/">框架相关</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/框架相关/前端技术/">前端技术</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/框架相关/权限管理/">权限管理</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/正则/">正则</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/爬虫/">爬虫</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/程序安装与配置/">程序安装与配置</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/zj2626.github.io/categories/计算机网络/">计算机网络</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/zj2626.github.io/tags/深入了解java虚拟机/" style="font-size: 15px;">深入了解java虚拟机</a> <a href="/zj2626.github.io/tags/java/" style="font-size: 15px;">java</a> <a href="/zj2626.github.io/tags/注解/" style="font-size: 15px;">注解</a> <a href="/zj2626.github.io/tags/元数据/" style="font-size: 15px;">元数据</a> <a href="/zj2626.github.io/tags/Maven/" style="font-size: 15px;">Maven</a> <a href="/zj2626.github.io/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/zj2626.github.io/tags/iframe/" style="font-size: 15px;">iframe</a> <a href="/zj2626.github.io/tags/Hexo优化/" style="font-size: 15px;">Hexo优化</a> <a href="/zj2626.github.io/tags/Shiro/" style="font-size: 15px;">Shiro</a> <a href="/zj2626.github.io/tags/jenkins/" style="font-size: 15px;">jenkins</a> <a href="/zj2626.github.io/tags/Git/" style="font-size: 15px;">Git</a> <a href="/zj2626.github.io/tags/maven/" style="font-size: 15px;">maven</a> <a href="/zj2626.github.io/tags/C语言/" style="font-size: 15px;">C语言</a> <a href="/zj2626.github.io/tags/junit/" style="font-size: 15px;">junit</a> <a href="/zj2626.github.io/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/zj2626.github.io/tags/定义/" style="font-size: 15px;">定义</a> <a href="/zj2626.github.io/tags/python/" style="font-size: 15px;">python</a> <a href="/zj2626.github.io/tags/爬虫/" style="font-size: 15px;">爬虫</a> <a href="/zj2626.github.io/tags/转码/" style="font-size: 15px;">转码</a> <a href="/zj2626.github.io/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/zj2626.github.io/tags/DBCP/" style="font-size: 15px;">DBCP</a> <a href="/zj2626.github.io/tags/Dom4j/" style="font-size: 15px;">Dom4j</a> <a href="/zj2626.github.io/tags/常用命令/" style="font-size: 15px;">常用命令</a> <a href="/zj2626.github.io/tags/shell/" style="font-size: 15px;">shell</a> <a href="/zj2626.github.io/tags/Mongodb/" style="font-size: 15px;">Mongodb</a> <a href="/zj2626.github.io/tags/Hibernate/" style="font-size: 15px;">Hibernate</a> <a href="/zj2626.github.io/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/zj2626.github.io/tags/存储过程/" style="font-size: 15px;">存储过程</a> <a href="/zj2626.github.io/tags/CRUD/" style="font-size: 15px;">CRUD</a> <a href="/zj2626.github.io/tags/ThreadLocal/" style="font-size: 15px;">ThreadLocal</a> <a href="/zj2626.github.io/tags/XPath/" style="font-size: 15px;">XPath</a> <a href="/zj2626.github.io/tags/C3P0/" style="font-size: 15px;">C3P0</a> <a href="/zj2626.github.io/tags/DRUID/" style="font-size: 15px;">DRUID</a> <a href="/zj2626.github.io/tags/工具类/" style="font-size: 15px;">工具类</a> <a href="/zj2626.github.io/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/zj2626.github.io/tags/jaxp/" style="font-size: 15px;">jaxp</a> <a href="/zj2626.github.io/tags/JDBC/" style="font-size: 15px;">JDBC</a> <a href="/zj2626.github.io/tags/Blob/" style="font-size: 15px;">Blob</a> <a href="/zj2626.github.io/tags/事务/" style="font-size: 15px;">事务</a> <a href="/zj2626.github.io/tags/sax/" style="font-size: 15px;">sax</a> <a href="/zj2626.github.io/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/zj2626.github.io/tags/逻辑回归/" style="font-size: 15px;">逻辑回归</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/zj2626.github.io/2021/06/01/20210601001_OutOfMemoryError/">4.OutOfMemoryError</a></li><li class="post-list-item"><a class="post-list-link" href="/zj2626.github.io/2021/06/01/20170924_VM-options配置/">VM options配置</a></li><li class="post-list-item"><a class="post-list-link" href="/zj2626.github.io/2021/06/01/20170924_JVM运行原理/">JVM运行原理</a></li><li class="post-list-item"><a class="post-list-link" href="/zj2626.github.io/2021/06/01/20170924_JVM的年轻代以及GC回收细节/">JVM的年轻代以及GC回收细节</a></li><li class="post-list-item"><a class="post-list-link" href="/zj2626.github.io/2021/06/01/20170924_GC之间的区别/">Minor GC、Major GC和Full GC之间的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/zj2626.github.io/2021/06/01/201703101259_垃圾收集器与内存分配策略/">垃圾收集器与内存分配策略</a></li><li class="post-list-item"><a class="post-list-link" href="/zj2626.github.io/2021/06/01/201703092017_对象在HotSpot虚拟机中/">对象在HotSpot虚拟机中</a></li><li class="post-list-item"><a class="post-list-link" href="/zj2626.github.io/2021/03/11/2018031301/">使用多种算法对泰坦尼克号乘客获救原因进行分析</a></li><li class="post-list-item"><a class="post-list-link" href="/zj2626.github.io/2021/03/11/2018031201/">scikit-learn数据预处理fit_transform()与transform()的区别(转)</a></li><li class="post-list-item"><a class="post-list-link" href="/zj2626.github.io/2021/03/11/2018031202/">关于使用sklearn进行数据预处理-归一化/标准化/正则化(转)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/zj2626/" title="github" target="_blank">github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/zj2626.github.io/." rel="nofollow">ZJ_BLOG.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/zj2626.github.io/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/zj2626.github.io/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/zj2626.github.io/js/search.js?v=0.0.1"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/zj2626.github.io/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function () {
    var hm = document.createElement("script");
    hm.src = '//hm.baidu.com/hm.js?' + 'c9a692191e9aca9e30daa3f6326cc789';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript" src="/zj2626.github.io/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/zj2626.github.io/js/smartresize.js?v=0.0.1"></script></div></body></html>